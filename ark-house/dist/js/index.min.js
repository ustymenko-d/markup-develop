(()=>{var __webpack_modules__={"./node_modules/lenis/dist/lenis.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (/* binding */ Lenis)\n/* harmony export */ });\n// package.json\nvar version = "1.1.14";\n\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n  return (n % d + d) % d;\n}\n\n// packages/core/src/animate.ts\nvar Animate = class {\n  isRunning = false;\n  value = 0;\n  from = 0;\n  to = 0;\n  currentTime = 0;\n  // These are instanciated in the fromTo method\n  lerp;\n  duration;\n  easing;\n  onUpdate;\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime) {\n    if (!this.isRunning) return;\n    let completed = false;\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime;\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n      completed = linearProgress >= 1;\n      const easedProgress = completed ? 1 : this.easing(linearProgress);\n      this.value = this.from + (this.to - this.from) * easedProgress;\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to;\n        completed = true;\n      }\n    } else {\n      this.value = this.to;\n      completed = true;\n    }\n    if (completed) {\n      this.stop();\n    }\n    this.onUpdate?.(this.value, completed);\n  }\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false;\n  }\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n    this.from = this.value = from;\n    this.to = to;\n    this.lerp = lerp2;\n    this.duration = duration;\n    this.easing = easing;\n    this.currentTime = 0;\n    this.isRunning = true;\n    onStart?.();\n    this.onUpdate = onUpdate;\n  }\n};\n\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n  let timer;\n  return function(...args) {\n    let context = this;\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = void 0;\n      callback.apply(context, args);\n    }, delay);\n  };\n}\n\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n  constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}) {\n    this.wrapper = wrapper;\n    this.content = content;\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue);\n      if (this.wrapper instanceof Window) {\n        window.addEventListener("resize", this.debouncedResize, false);\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n        this.wrapperResizeObserver.observe(this.wrapper);\n      }\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n      this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  width = 0;\n  height = 0;\n  scrollHeight = 0;\n  scrollWidth = 0;\n  // These are instanciated in the constructor as they need information from the options\n  debouncedResize;\n  wrapperResizeObserver;\n  contentResizeObserver;\n  destroy() {\n    this.wrapperResizeObserver?.disconnect();\n    this.contentResizeObserver?.disconnect();\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener("resize", this.debouncedResize, false);\n    }\n  }\n  resize = () => {\n    this.onWrapperResize();\n    this.onContentResize();\n  };\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n    } else {\n      this.width = this.wrapper.clientWidth;\n      this.height = this.wrapper.clientHeight;\n    }\n  };\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight;\n      this.scrollWidth = this.content.scrollWidth;\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight;\n      this.scrollWidth = this.wrapper.scrollWidth;\n    }\n  };\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n};\n\n// packages/core/src/emitter.ts\nvar Emitter = class {\n  events = {};\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event, ...args) {\n    let callbacks = this.events[event] || [];\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args);\n    }\n  }\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb]);\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i);\n    };\n  }\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event, callback) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i);\n  }\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {};\n  }\n};\n\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = { passive: false };\nvar VirtualScroll = class {\n  constructor(element, options = { wheelMultiplier: 1, touchMultiplier: 1 }) {\n    this.element = element;\n    this.options = options;\n    window.addEventListener("resize", this.onWindowResize, false);\n    this.onWindowResize();\n    this.element.addEventListener("wheel", this.onWheel, listenerOptions);\n    this.element.addEventListener(\n      "touchstart",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.addEventListener(\n      "touchmove",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.addEventListener("touchend", this.onTouchEnd, listenerOptions);\n  }\n  touchStart = {\n    x: 0,\n    y: 0\n  };\n  lastDelta = {\n    x: 0,\n    y: 0\n  };\n  window = {\n    width: 0,\n    height: 0\n  };\n  emitter = new Emitter();\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy();\n    window.removeEventListener("resize", this.onWindowResize, false);\n    this.element.removeEventListener("wheel", this.onWheel, listenerOptions);\n    this.element.removeEventListener(\n      "touchstart",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      "touchmove",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      "touchend",\n      this.onTouchEnd,\n      listenerOptions\n    );\n  }\n  /**\n   * Event handler for \'touchstart\' event\n   *\n   * @param event Touch event\n   */\n  onTouchStart = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: 0,\n      y: 0\n    };\n    this.emitter.emit("scroll", {\n      deltaX: 0,\n      deltaY: 0,\n      event\n    });\n  };\n  /** Event handler for \'touchmove\' event */\n  onTouchMove = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY\n    };\n    this.emitter.emit("scroll", {\n      deltaX,\n      deltaY,\n      event\n    });\n  };\n  onTouchEnd = (event) => {\n    this.emitter.emit("scroll", {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event\n    });\n  };\n  /** Event handler for \'wheel\' event */\n  onWheel = (event) => {\n    let { deltaX, deltaY, deltaMode } = event;\n    const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n    const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n    deltaX *= multiplierX;\n    deltaY *= multiplierY;\n    deltaX *= this.options.wheelMultiplier;\n    deltaY *= this.options.wheelMultiplier;\n    this.emitter.emit("scroll", { deltaX, deltaY, event });\n  };\n  onWindowResize = () => {\n    this.window = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  };\n};\n\n// packages/core/src/lenis.ts\nvar Lenis = class {\n  _isScrolling = false;\n  // true when scroll is animating\n  _isStopped = false;\n  // true if user should not be able to scroll - enable/disable programmatically\n  _isLocked = false;\n  // same as isStopped but enabled/disabled when scroll reaches target\n  _preventNextNativeScrollEvent = false;\n  _resetVelocityTimeout = null;\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching;\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0;\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: \'bar\'\n   *   }\n   * })\n   */\n  userData = {};\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0;\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0;\n  /**\n   * The direction of the scroll\n   */\n  direction = 0;\n  /**\n   * The options passed to the lenis instance\n   */\n  options;\n  /**\n   * The target scroll value\n   */\n  targetScroll;\n  /**\n   * The animated scroll value\n   */\n  animatedScroll;\n  // These are instanciated here as they don\'t need information from the options\n  animate = new Animate();\n  emitter = new Emitter();\n  // These are instanciated in the constructor as they need information from the options\n  dimensions;\n  // This is not private because it\'s used in the Snap class\n  virtualScroll;\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaMultiplier = 35,\n    duration,\n    // in seconds\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp: lerp2 = 0.1,\n    infinite = false,\n    orientation = "vertical",\n    // vertical, horizontal\n    gestureOrientation = "vertical",\n    // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    __experimental__naiveDimensions = false\n  } = {}) {\n    window.lenisVersion = version;\n    if (!wrapper || wrapper === document.documentElement || wrapper === document.body) {\n      wrapper = window;\n    }\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaMultiplier,\n      duration,\n      easing,\n      lerp: lerp2,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      __experimental__naiveDimensions\n    };\n    this.dimensions = new Dimensions(wrapper, content, { autoResize });\n    this.updateClassName();\n    this.targetScroll = this.animatedScroll = this.actualScroll;\n    this.options.wrapper.addEventListener("scroll", this.onNativeScroll, false);\n    this.options.wrapper.addEventListener(\n      "pointerdown",\n      this.onPointerDown,\n      false\n    );\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier\n    });\n    this.virtualScroll.on("scroll", this.onVirtualScroll);\n  }\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy();\n    this.options.wrapper.removeEventListener(\n      "scroll",\n      this.onNativeScroll,\n      false\n    );\n    this.options.wrapper.removeEventListener(\n      "pointerdown",\n      this.onPointerDown,\n      false\n    );\n    this.virtualScroll.destroy();\n    this.dimensions.destroy();\n    this.cleanUpClassName();\n  }\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  off(event, callback) {\n    return this.emitter.off(event, callback);\n  }\n  setScroll(scroll) {\n    if (this.isHorizontal) {\n      this.rootElement.scrollLeft = scroll;\n    } else {\n      this.rootElement.scrollTop = scroll;\n    }\n  }\n  onPointerDown = (event) => {\n    if (event.button === 1) {\n      this.reset();\n    }\n  };\n  onVirtualScroll = (data) => {\n    if (typeof this.options.virtualScroll === "function" && this.options.virtualScroll(data) === false)\n      return;\n    const { deltaX, deltaY, event } = data;\n    this.emitter.emit("virtual-scroll", { deltaX, deltaY, event });\n    if (event.ctrlKey) return;\n    if (event.lenisStopPropagation) return;\n    const isTouch = event.type.includes("touch");\n    const isWheel = event.type.includes("wheel");\n    this.isTouching = event.type === "touchstart" || event.type === "touchmove";\n    const isTapToStop = this.options.syncTouch && isTouch && event.type === "touchstart" && !this.isStopped && !this.isLocked;\n    if (isTapToStop) {\n      this.reset();\n      return;\n    }\n    const isClick = deltaX === 0 && deltaY === 0;\n    const isUnknownGesture = this.options.gestureOrientation === "vertical" && deltaY === 0 || this.options.gestureOrientation === "horizontal" && deltaX === 0;\n    if (isClick || isUnknownGesture) {\n      return;\n    }\n    let composedPath = event.composedPath();\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n    const prevent = this.options.prevent;\n    if (!!composedPath.find(\n      (node) => node instanceof HTMLElement && (typeof prevent === "function" && prevent?.(node) || node.hasAttribute?.("data-lenis-prevent") || isTouch && node.hasAttribute?.("data-lenis-prevent-touch") || isWheel && node.hasAttribute?.("data-lenis-prevent-wheel"))\n    ))\n      return;\n    if (this.isStopped || this.isLocked) {\n      event.preventDefault();\n      return;\n    }\n    const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n    if (!isSmooth) {\n      this.isScrolling = "native";\n      this.animate.stop();\n      event.lenisStopPropagation = true;\n      return;\n    }\n    let delta = deltaY;\n    if (this.options.gestureOrientation === "both") {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n    } else if (this.options.gestureOrientation === "horizontal") {\n      delta = deltaX;\n    }\n    if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n      event.lenisStopPropagation = true;\n    }\n    event.preventDefault();\n    const syncTouch = isTouch && this.options.syncTouch;\n    const isTouchEnd = isTouch && event.type === "touchend";\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 5;\n    if (hasTouchInertia) {\n      delta = this.velocity * this.options.touchInertiaMultiplier;\n    }\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...syncTouch ? {\n        lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n      } : {\n        lerp: this.options.lerp,\n        duration: this.options.duration,\n        easing: this.options.easing\n      }\n    });\n  };\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize();\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.emit();\n  }\n  emit() {\n    this.emitter.emit("scroll", this);\n  }\n  onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout);\n      this._resetVelocityTimeout = null;\n    }\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false;\n      return;\n    }\n    if (this.isScrolling === false || this.isScrolling === "native") {\n      const lastScroll = this.animatedScroll;\n      this.animatedScroll = this.targetScroll = this.actualScroll;\n      this.lastVelocity = this.velocity;\n      this.velocity = this.animatedScroll - lastScroll;\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      );\n      this.isScrolling = "native";\n      this.emit();\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity;\n          this.velocity = 0;\n          this.isScrolling = false;\n          this.emit();\n        }, 400);\n      }\n    }\n  };\n  reset() {\n    this.isLocked = false;\n    this.isScrolling = false;\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.lastVelocity = this.velocity = 0;\n    this.animate.stop();\n  }\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return;\n    this.isStopped = false;\n    this.reset();\n  }\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    this.animate.stop();\n    this.reset();\n  }\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf(time) {\n    const deltaTime = time - (this.time || time);\n    this.time = time;\n    this.animate.advance(deltaTime * 1e-3);\n  }\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log(\'onStart\')\n   *   },\n   *   onComplete: () => {\n   *     console.log(\'onComplete\')\n   *   },\n   * })\n   */\n  scrollTo(target, {\n    offset = 0,\n    immediate = false,\n    lock = false,\n    duration = this.options.duration,\n    easing = this.options.easing,\n    lerp: lerp2 = this.options.lerp,\n    onStart,\n    onComplete,\n    force = false,\n    // scroll even if stopped\n    programmatic = true,\n    // called from outside of the class\n    userData\n  } = {}) {\n    if ((this.isStopped || this.isLocked) && !force) return;\n    if (typeof target === "string" && ["top", "left", "start"].includes(target)) {\n      target = 0;\n    } else if (typeof target === "string" && ["bottom", "right", "end"].includes(target)) {\n      target = this.limit;\n    } else {\n      let node;\n      if (typeof target === "string") {\n        node = document.querySelector(target);\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        node = target;\n      }\n      if (node) {\n        if (this.options.wrapper !== window) {\n          const wrapperRect = this.rootElement.getBoundingClientRect();\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n        }\n        const rect = node.getBoundingClientRect();\n        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n      }\n    }\n    if (typeof target !== "number") return;\n    target += offset;\n    target = Math.round(target);\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll;\n      }\n    } else {\n      target = clamp(0, target, this.limit);\n    }\n    if (target === this.targetScroll) {\n      onStart?.(this);\n      onComplete?.(this);\n      return;\n    }\n    this.userData = userData ?? {};\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target;\n      this.setScroll(this.scroll);\n      this.reset();\n      this.preventNextNativeScrollEvent();\n      this.emit();\n      onComplete?.(this);\n      this.userData = {};\n      return;\n    }\n    if (!programmatic) {\n      this.targetScroll = target;\n    }\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp: lerp2,\n      onStart: () => {\n        if (lock) this.isLocked = true;\n        this.isScrolling = "smooth";\n        onStart?.(this);\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = "smooth";\n        this.lastVelocity = this.velocity;\n        this.velocity = value - this.animatedScroll;\n        this.direction = Math.sign(this.velocity);\n        this.animatedScroll = value;\n        this.setScroll(this.scroll);\n        if (programmatic) {\n          this.targetScroll = value;\n        }\n        if (!completed) this.emit();\n        if (completed) {\n          this.reset();\n          this.emit();\n          onComplete?.(this);\n          this.userData = {};\n          this.preventNextNativeScrollEvent();\n        }\n      }\n    });\n  }\n  preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true;\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false;\n    });\n  }\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? "x" : "y"];\n    }\n  }\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === "horizontal";\n  }\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;\n  }\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n  }\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    return this.limit === 0 ? 1 : this.scroll / this.limit;\n  }\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling;\n  }\n  set isScrolling(value) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped;\n  }\n  set isStopped(value) {\n    if (this._isStopped !== value) {\n      this._isStopped = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    if (this._isLocked !== value) {\n      this._isLocked = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === "smooth";\n  }\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = "lenis";\n    if (this.isStopped) className += " lenis-stopped";\n    if (this.isLocked) className += " lenis-locked";\n    if (this.isScrolling) className += " lenis-scrolling";\n    if (this.isScrolling === "smooth") className += " lenis-smooth";\n    return className;\n  }\n  updateClassName() {\n    this.cleanUpClassName();\n    this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n  }\n  cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, "").trim();\n  }\n};\n\n//# sourceMappingURL=lenis.mjs.map\n\n//# sourceURL=webpack:///./node_modules/lenis/dist/lenis.mjs?')},"./src/js/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_header_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/header.js */ "./src/js/modules/header.js");\n/* harmony import */ var _modules_form_toggler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/form-toggler.js */ "./src/js/modules/form-toggler.js");\n/* harmony import */ var _modules_tabs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/tabs.js */ "./src/js/modules/tabs.js");\n/* harmony import */ var _modules_to_top_btn_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/to-top-btn.js */ "./src/js/modules/to-top-btn.js");\n/* harmony import */ var _modules_modal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/modal.js */ "./src/js/modules/modal.js");\n/* harmony import */ var _modules_gallery_modal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/gallery-modal.js */ "./src/js/modules/gallery-modal.js");\n/* harmony import */ var _modules_animation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/animation.js */ "./src/js/modules/animation.js");\n/* harmony import */ var _modules_lenis_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/lenis.js */ "./src/js/modules/lenis.js");\n/* harmony import */ var _modules_webp_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/webp.js */ "./src/js/modules/webp.js");\n\n\n\n\n\n\n\n\n\n\n_modules_webp_js__WEBPACK_IMPORTED_MODULE_8__.isWebp();\n\n\n//# sourceURL=webpack:///./src/js/index.js?')},"./src/js/modules/animation.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\nfunction onEntry(entry) {\n\tentry.forEach((change) => {\n\t\tif (change.isIntersecting) {\n\t\t\tchange.target.classList.add('_element-show');\n\t\t}\n\t});\n}\n\nlet options = {\n\tthreshold: 0.3,\n};\nlet observer = new IntersectionObserver(onEntry, options);\nlet animatedElements = document.querySelectorAll('.element-animation');\n\nif (animatedElements) {\n\tfor (let elem of animatedElements) {\n\t\tobserver.observe(elem);\n\t}\n}\n\n\n//# sourceURL=webpack:///./src/js/modules/animation.js?")},"./src/js/modules/focus-lock.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   focusLock: () => (/* binding */ focusLock)\n/* harmony export */ });\n/* harmony import */ var _lenis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lenis.js */ \"./src/js/modules/lenis.js\");\n\n\nfunction focusLock(target) {\n\tconst focusableElements = target.querySelectorAll(\n\t\t'a[href]:not([disabled]), button:not([disabled])'\n\t)\n\tconst firstFocusableElement = focusableElements[0]\n\tconst lastFocusableElement = focusableElements[focusableElements.length - 1]\n\tconst KEYCODE_TAB = 9\n\n\tfirstFocusableElement.focus()\n\n\ttarget.addEventListener('keydown', (e) => {\n\t\tif (\n\t\t\tdocument.documentElement.classList.contains('_scroll-lock') &&\n\t\t\t(e.key === 'Tab' || e.keyCode === KEYCODE_TAB)\n\t\t) {\n\t\t\tif (e.shiftKey) {\n\t\t\t\tif (document.activeElement === firstFocusableElement) {\n\t\t\t\t\tlastFocusableElement.focus()\n\t\t\t\t\te.preventDefault()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (document.activeElement === lastFocusableElement) {\n\t\t\t\t\tfirstFocusableElement.focus()\n\t\t\t\t\te.preventDefault()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\n\n//# sourceURL=webpack:///./src/js/modules/focus-lock.js?")},"./src/js/modules/form-toggler.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\nconst form = document.forms[0];\n\nif (form) {\n\tconst inputToggler = form.querySelector('#input-toggler');\n\n\tinputToggler.addEventListener('click', (e) => {\n\t\tif (e.target.classList.contains('toggler__button_active')) {\n\t\t\treturn;\n\t\t} else {\n\t\t\ttoggleInputType(inputToggler);\n\n\t\t\tinputToggler.querySelectorAll('.toggler__button').forEach((btn) => {\n\t\t\t\tbtn.classList.toggle('toggler__button_active');\n\t\t\t});\n\t\t}\n\t});\n\n\tform.addEventListener('submit', (e) => {\n\t\te.preventDefault();\n\n\t\talert('Successful! (In fact, nothing was sent anywhere)');\n\t});\n}\n\nfunction toggleInputType(toggler) {\n\tconst targetType = toggler.dataset.inputType;\n\tconst changeInput = form.querySelector(`[type=\"${targetType}\"]`);\n\n\tconst newName = targetType === 'tel' ? 'mail' : 'phone';\n\tconst newType = targetType === 'tel' ? 'email' : 'tel';\n\tconst newPlaceholder = targetType === 'tel' ? 'username@mail.com' : '+0(123) 456-7890';\n\tconst newpattern = targetType === 'tel' ? '[a-z0-9._%+-]+@[a-z0-9.-]+\\\\.[a-z]{2,4}$' : '[0-9]{11}';\n\n\ttoggler.dataset.inputType = newType;\n\tchangeInput.setAttribute('name', newName);\n\tchangeInput.setAttribute('placeholder', newPlaceholder);\n\tchangeInput.setAttribute('pattern', newpattern);\n\tchangeInput.setAttribute('type', newType);\n}\n\n\n//# sourceURL=webpack:///./src/js/modules/form-toggler.js?")},"./src/js/modules/gallery-modal.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lenis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lenis.js */ \"./src/js/modules/lenis.js\");\n\n\nconst galleryLinks = document.querySelectorAll('a.gallery__card-link')\n\nif (galleryLinks) {\n\tgalleryLinks.forEach((link) => {\n\t\tlink.addEventListener('click', (e) => {\n\t\t\te.preventDefault()\n\n\t\t\t;(0,_lenis_js__WEBPACK_IMPORTED_MODULE_0__.handlePauseScroll)()\n\t\t\tconst modalToOpen = e.currentTarget.nextElementSibling\n\t\t\tmodalToOpen.showModal()\n\t\t\tmodalToOpen.addEventListener('close', () => (0,_lenis_js__WEBPACK_IMPORTED_MODULE_0__.handleResumeScroll)())\n\n\t\t\t// Animation\n\t\t\tconst onAnimationEnd = () => {\n\t\t\t\tmodalToOpen.classList.remove('hide')\n\t\t\t\tmodalToOpen.close()\n\t\t\t\tmodalToOpen.removeEventListener('animationend', onAnimationEnd)\n\t\t\t}\n\t\t\t// =========\n\n\t\t\t// Backdrop close\n\t\t\tconst handleBackdropClick = (e) => {\n\t\t\t\tconst modalRect = modalToOpen.getBoundingClientRect()\n\n\t\t\t\tif (\n\t\t\t\t\te.clientX < modalRect.left ||\n\t\t\t\t\te.clientX > modalRect.right ||\n\t\t\t\t\te.clientY < modalRect.top ||\n\t\t\t\t\te.clientY > modalRect.bottom\n\t\t\t\t) {\n\t\t\t\t\tmodalToOpen.classList.add('hide')\n\t\t\t\t\tmodalToOpen.addEventListener('animationend', onAnimationEnd)\n\t\t\t\t}\n\t\t\t}\n\t\t\tmodalToOpen.addEventListener('click', handleBackdropClick)\n\t\t\t// ==============\n\n\t\t\tconst modalCloseButton = modalToOpen.querySelector('.modal__close-btn')\n\n\t\t\tmodalCloseButton.addEventListener('click', (e) => {\n\t\t\t\tmodalToOpen.classList.add('hide')\n\t\t\t\tmodalToOpen.addEventListener('animationend', onAnimationEnd)\n\t\t\t})\n\t\t})\n\t})\n}\n\n\n//# sourceURL=webpack:///./src/js/modules/gallery-modal.js?")},"./src/js/modules/header.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _focus_lock_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./focus-lock.js */ \"./src/js/modules/focus-lock.js\");\n\n\n// Header nav\nconst header = document.querySelector('.header');\nconst menuButton = document.querySelector('.navigation__toggler');\nconst menuBody = document.querySelector('.navigation__links-list');\nconst lockPaddingValue = window.innerWidth - document.querySelector('.page').offsetWidth + 'px';\nconst lockPadding = document.querySelectorAll('.lock-padding');\nlet menuIsOpen = false;\nconst media = window.matchMedia('(width < 768px)');\n\nfunction setupMenu(e) {\n\tif (e.matches) {\n\t\tmenuBody.setAttribute('inert', '');\n\t\tmenuBody.setAttribute('aria-hidden', 'true');\n\t\tmenuBody.style.transition = 'none';\n\t\tmenuButton.removeAttribute('inert');\n\t} else {\n\t\tmenuBody.removeAttribute('inert');\n\t\tmenuBody.setAttribute('aria-hidden', 'false');\n\t\tmenuButton.setAttribute('inert', '');\n\t}\n}\n\nsetupMenu(media);\nmedia.addEventListener('change', (e) => {\n\tsetupMenu(e);\n});\n\ndocument.querySelector('.header').addEventListener('keydown', (e) => {\n\tif (menuIsOpen && e.code === 'Escape') closeMenu();\n});\n\nif (menuButton) {\n\tmenuButton.addEventListener('click', () => {\n\t\tdocument.documentElement.classList.contains('_scroll-lock') ? closeMenu() : openMenu();\n\t});\n}\n\nwindow.addEventListener('resize', (e) => {\n\tif (e.currentTarget.innerWidth >= 768 && menuIsOpen) closeMenu();\n});\n\nmenuBody.addEventListener('click', (e) => {\n\tif (e.target.classList.contains('nav-item__link') && menuIsOpen) {\n\t\tcloseMenu();\n\t}\n});\n\nfunction openMenu() {\n\tdocument.documentElement.classList.add('_scroll-lock');\n\tmenuButton.classList.add('navigation__toggler_active');\n\tmenuButton.setAttribute('aria-expanded', true);\n\tmenuBody.removeAttribute('inert');\n\tmenuBody.removeAttribute('style');\n\tmenuBody.setAttribute('aria-hidden', false);\n\tmenuBody.classList.add('navigation__links-list_active');\n\t(0,_focus_lock_js__WEBPACK_IMPORTED_MODULE_0__.focusLock)(document.querySelector('.header'));\n\tif (lockPadding.length > 0) {\n\t\tlockPadding.forEach((el) => (el.style.paddingRight = lockPaddingValue));\n\t}\n\tdocument.body.style.paddingRight = lockPaddingValue;\n\n\tmenuIsOpen = true;\n}\n\nfunction closeMenu() {\n\tdocument.documentElement.classList.remove('_scroll-lock');\n\tmenuButton.setAttribute('aria-expanded', false);\n\tmenuButton.classList.remove('navigation__toggler_active');\n\tmenuBody.setAttribute('inert', '');\n\tmenuBody.setAttribute('aria-hidden', true);\n\tsetTimeout(() => {\n\t\tmenuBody.style.transition = 'none';\n\t}, 400);\n\tmenuBody.classList.remove('navigation__links-list_active');\n\n\tif (lockPadding.length > 0) {\n\t\tlockPadding.forEach((el) => (el.style.paddingRight = 0));\n\t}\n\tdocument.body.style.paddingRight = 0;\n\n\tmenuIsOpen = false;\n}\n\n\n//# sourceURL=webpack:///./src/js/modules/header.js?")},"./src/js/modules/lenis.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handlePauseScroll: () => (/* binding */ handlePauseScroll),\n/* harmony export */   handleResumeScroll: () => (/* binding */ handleResumeScroll)\n/* harmony export */ });\n/* harmony import */ var lenis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lenis */ "./node_modules/lenis/dist/lenis.mjs");\n\n\nlet lenis\n\nconst lenisInit = () => {\n\tlenis = new lenis__WEBPACK_IMPORTED_MODULE_0__["default"]()\n\n\tfunction raf(time) {\n\t\tlenis.raf(time)\n\t\trequestAnimationFrame(raf)\n\t}\n\n\trequestAnimationFrame(raf)\n}\n\nlenisInit()\n\nconst handlePauseScroll = () => {\n\tlenis.destroy()\n}\n\nconst handleResumeScroll = () => {\n\tlenisInit()\n}\n\n\n//# sourceURL=webpack:///./src/js/modules/lenis.js?')},"./src/js/modules/modal.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _focus_lock_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./focus-lock.js */ \"./src/js/modules/focus-lock.js\");\n/* harmony import */ var _lenis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lenis.js */ \"./src/js/modules/lenis.js\");\n\n\n\nconst body = document.querySelector('body')\nconst openDialogButtons = document.querySelectorAll(\n\t'[data-assignment=open-dialog]'\n)\nconst timeoutToUnlock = 400\nlet unlock = true\nlet rootButton\n\nif (openDialogButtons.length) {\n\tconst closeDialogButtons = document.querySelectorAll(\n\t\t'[data-assignment=close-dialog]'\n\t)\n\n\tif (closeDialogButtons.length) {\n\t\tbody.addEventListener('click', (e) => {\n\t\t\tif (e.target.dataset.assignment === 'close-dialog') {\n\t\t\t\tmodalClose(e.target.closest('[role=\"dialog\"]'))\n\t\t\t\te.preventDefault()\n\t\t\t} else if (e.target.classList.contains('close-backdrop')) {\n\t\t\t\tlet parentWrap = e.target.closest('.dialogs')\n\t\t\t\tmodalClose(parentWrap.querySelector('.modal_open'))\n\t\t\t}\n\t\t})\n\t}\n\n\tbody.addEventListener('click', (e) => {\n\t\tconst fakeLink = e.target.closest('a[data-assignment=\"open-dialog\"]')\n\n\t\tif (fakeLink && fakeLink.dataset.assignment === 'open-dialog') {\n\t\t\tconst targetID = fakeLink.dataset.target\n\t\t\tconst modalToOpen = document.querySelector(`${targetID}`)\n\n\t\t\tif (fakeLink.dataset.rootModal) {\n\t\t\t\trootButton = fakeLink\n\t\t\t}\n\n\t\t\tmodalOpen(\n\t\t\t\tmodalToOpen,\n\t\t\t\te.target.closest('a[data-assignment=\"open-dialog\"]')\n\t\t\t)\n\t\t\te.preventDefault()\n\t\t}\n\t})\n\n\tdocument.addEventListener('keydown', (e) => {\n\t\tif (e.code === 'Escape') {\n\t\t\tconst openModal = document.querySelector('.modal_open')\n\n\t\t\tif (openModal) modalClose(openModal)\n\t\t}\n\t})\n}\n\nfunction modalOpen(targetToOpen, test) {\n\tif (targetToOpen && unlock) {\n\t\t(0,_lenis_js__WEBPACK_IMPORTED_MODULE_1__.handlePauseScroll)()\n\t\tconst currentOpenModal = document.querySelector('.modal_open')\n\n\t\tcurrentOpenModal ? modalClose(currentOpenModal, false) : bodyLock()\n\n\t\tconst targetWrapper = targetToOpen.closest('.dialogs')\n\n\t\tif (\n\t\t\ttest.classList.contains('projects__card-link') &&\n\t\t\t!targetWrapper.querySelector('a[href=\"project.html\"]')\n\t\t) {\n\t\t\tconst projectLink = document.createElement('a')\n\t\t\tprojectLink.classList.add('modal__button')\n\t\t\tprojectLink.classList.add('button')\n\t\t\tprojectLink.setAttribute('href', 'project.html')\n\t\t\tprojectLink.textContent = 'Go to progect page'\n\n\t\t\ttargetWrapper.querySelector('.modal__button').after(projectLink)\n\t\t}\n\n\t\ttargetWrapper.removeAttribute('hidden')\n\t\ttargetWrapper.classList.add('dialogs_open')\n\t\ttargetToOpen.removeAttribute('hidden')\n\t\ttargetToOpen.classList.add('modal_open')\n\n\t\t;(0,_focus_lock_js__WEBPACK_IMPORTED_MODULE_0__.focusLock)(targetToOpen)\n\t}\n}\n\nfunction modalClose(targetToClose, doUnlock = true) {\n\tif (unlock) {\n\t\t(0,_lenis_js__WEBPACK_IMPORTED_MODULE_1__.handleResumeScroll)()\n\t\ttargetToClose.classList.remove('modal_open')\n\t\ttargetToClose.setAttribute('hidden', '')\n\n\t\ttargetToClose.closest('.dialogs').classList.remove('dialogs_open')\n\t\ttargetToClose.closest('.dialogs').setAttribute('hidden', '')\n\n\t\tif (doUnlock) {\n\t\t\tbodyUnlock()\n\n\t\t\trootButton.focus()\n\t\t}\n\t}\n}\n\nfunction bodyLock() {\n\tconst lockPadding = document.querySelectorAll('.lock-padding') // For position:fixed elements\n\n\tconst lockPaddingValue = window.innerWidth - body.offsetWidth + 'px'\n\n\tif (lockPadding.length) {\n\t\tlockPadding.forEach((el) => {\n\t\t\tel.style.left =\n\t\t\t\tparseFloat(window.getComputedStyle(el).left) + lockPaddingValue\n\t\t})\n\t}\n\n\tbody.style.paddingRight = lockPaddingValue\n\tbody.parentElement.classList.add('_scroll-lock')\n\n\tunlock = false\n\tsetTimeout(() => {\n\t\tunlock = true\n\t}, timeoutToUnlock)\n}\n\nfunction bodyUnlock() {\n\tconst lockPadding = document.querySelectorAll('.lock-padding')\n\n\tsetTimeout(() => {\n\t\tif (lockPadding.length) {\n\t\t\tlockPadding.forEach((el) => {\n\t\t\t\tel.removeAttribute('style')\n\t\t\t})\n\t\t}\n\t\tbody.removeAttribute('style')\n\t\tbody.parentElement.classList.remove('_scroll-lock')\n\t}, timeoutToUnlock)\n\n\tunlock = false\n\tsetTimeout(() => {\n\t\tunlock = true\n\t}, timeoutToUnlock)\n}\n\n\n//# sourceURL=webpack:///./src/js/modules/modal.js?")},"./src/js/modules/tabs.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\nclass TabsManual {\n\tconstructor(groupNode) {\n\t\tthis.tablistNode = groupNode;\n\n\t\tthis.tabs = [];\n\n\t\tthis.firstTab = null;\n\t\tthis.lastTab = null;\n\n\t\tthis.tabs = Array.from(this.tablistNode.querySelectorAll('[role=tab]'));\n\t\tthis.tabpanels = [];\n\n\t\tfor (let i = 0; i < this.tabs.length; i++) {\n\t\t\tlet tab = this.tabs[i];\n\t\t\tlet tabpanel = document.getElementById(tab.getAttribute('aria-controls'));\n\n\t\t\ttab.tabIndex = -1;\n\t\t\ttab.setAttribute('aria-selected', 'false');\n\t\t\tthis.tabpanels.push(tabpanel);\n\n\t\t\ttab.addEventListener('keydown', this.onKeydown.bind(this));\n\t\t\ttab.addEventListener('click', this.onClick.bind(this));\n\n\t\t\tif (!this.firstTab) {\n\t\t\t\tthis.firstTab = tab;\n\t\t\t}\n\t\t\tthis.lastTab = tab;\n\t\t}\n\n\t\tthis.setSelectedTab(this.firstTab);\n\t}\n\n\tsetSelectedTab(currentTab) {\n\t\tfor (let i = 0; i < this.tabs.length; i++) {\n\t\t\tlet tab = this.tabs[i];\n\t\t\tif (currentTab === tab) {\n\t\t\t\ttab.setAttribute('aria-selected', 'true');\n\t\t\t\ttab.removeAttribute('tabindex');\n\t\t\t\ttab.classList.add('tabs__item_active');\n\t\t\t\tthis.tabpanels[i].classList.remove('is-hidden');\n\t\t\t} else {\n\t\t\t\ttab.setAttribute('aria-selected', 'false');\n\t\t\t\ttab.tabIndex = -1;\n\t\t\t\ttab.classList.remove('tabs__item_active');\n\t\t\t\tthis.tabpanels[i].classList.add('is-hidden');\n\t\t\t}\n\t\t}\n\t}\n\n\tmoveFocusToTab(currentTab) {\n\t\tcurrentTab.focus();\n\t}\n\n\tmoveFocusToPreviousTab(currentTab) {\n\t\tlet index;\n\n\t\tif (currentTab === this.firstTab) {\n\t\t\tthis.moveFocusToTab(this.lastTab);\n\t\t} else {\n\t\t\tindex = this.tabs.indexOf(currentTab);\n\t\t\tthis.moveFocusToTab(this.tabs[index - 1]);\n\t\t}\n\t}\n\n\tmoveFocusToNextTab(currentTab) {\n\t\tlet index;\n\n\t\tif (currentTab === this.lastTab) {\n\t\t\tthis.moveFocusToTab(this.firstTab);\n\t\t} else {\n\t\t\tindex = this.tabs.indexOf(currentTab);\n\t\t\tthis.moveFocusToTab(this.tabs[index + 1]);\n\t\t}\n\t}\n\n\t// EVENT HANDLERS\n\n\tonKeydown(event) {\n\t\tlet tgt = event.currentTarget,\n\t\t\tflag = false;\n\n\t\tswitch (event.key) {\n\t\t\tcase 'ArrowUp':\n\t\t\tcase 'ArrowLeft':\n\t\t\t\tthis.moveFocusToPreviousTab(tgt);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ArrowDown':\n\t\t\tcase 'ArrowRight':\n\t\t\t\tthis.moveFocusToNextTab(tgt);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'Home':\n\t\t\t\tthis.moveFocusToTab(this.firstTab);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'End':\n\t\t\t\tthis.moveFocusToTab(this.lastTab);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tevent.stopPropagation();\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\tonClick(event) {\n\t\tthis.setSelectedTab(event.currentTarget);\n\t}\n}\n\nwindow.addEventListener('load', function () {\n\tlet tablists = document.querySelectorAll('[role=tablist].tabs__list');\n\tfor (let i = 0; i < tablists.length; i++) {\n\t\tnew TabsManual(tablists[i]);\n\t}\n});\n\n\n//# sourceURL=webpack:///./src/js/modules/tabs.js?")},"./src/js/modules/to-top-btn.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\nconst addToTop = () => {\n\tconst toTop = document.createElement('button');\n\ttoTop.classList.add('to-top');\n\ttoTop.classList.add('lock-padding');\n\ttoTop.tabIndex = 0;\n\ttoTop.addEventListener('click', () => {\n\t\twindow.scrollTo(0, 0);\n\t\ttoTop.classList.add('hidden');\n\t});\n\n\tdocument.body.append(toTop);\n};\n\nconst checkHide = (arg) => {\n\tconst toTop = document.querySelector('.to-top');\n\tconst media = arg.currentTarget.scrollY > document.documentElement.clientHeight;\n\n\tif (media && !toTop) {\n\t\taddToTop();\n\t}\n\n\tif (!media && toTop) {\n\t\ttoTop.classList.add('hidden');\n\t}\n\n\tif (media && toTop) toTop.classList.remove('hidden');\n};\n\nwindow.addEventListener('scroll', (e) => {\n\tcheckHide(e);\n});\n\n\n//# sourceURL=webpack:///./src/js/modules/to-top-btn.js?")},"./src/js/modules/webp.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isWebp: () => (/* binding */ isWebp)\n/* harmony export */ });\nfunction isWebp() {\n\tfunction testWebP(callback) {\n\t\tvar webP = new Image();\n\t\twebP.onload = webP.onerror = function () {\n\t\t\tcallback(webP.height == 2);\n\t\t};\n\t\twebP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';\n\t}\n\n\ttestWebP(function (support) {\n\t\tif (support == true) {\n\t\t\tdocument.querySelector('body').classList.add('webp');\n\t\t} else {\n\t\t\tdocument.querySelector('body').classList.add('no-webp');\n\t\t}\n\t});\n}\n\n\n//# sourceURL=webpack:///./src/js/modules/webp.js?")}},__webpack_module_cache__={};function __webpack_require__(t){var e=__webpack_module_cache__[t];return void 0!==e||(e=__webpack_module_cache__[t]={exports:{}},__webpack_modules__[t](e,e.exports,__webpack_require__)),e.exports}__webpack_require__.d=(t,e)=>{for(var n in e)__webpack_require__.o(e,n)&&!__webpack_require__.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},__webpack_require__.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),__webpack_require__.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/js/index.js")})();