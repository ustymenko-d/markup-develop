(()=>{var __webpack_modules__={"./node_modules/lenis/dist/lenis.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (/* binding */ Lenis)\n/* harmony export */ });\n// package.json\nvar version = "1.1.14";\n\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n  return (n % d + d) % d;\n}\n\n// packages/core/src/animate.ts\nvar Animate = class {\n  isRunning = false;\n  value = 0;\n  from = 0;\n  to = 0;\n  currentTime = 0;\n  // These are instanciated in the fromTo method\n  lerp;\n  duration;\n  easing;\n  onUpdate;\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime) {\n    if (!this.isRunning) return;\n    let completed = false;\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime;\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n      completed = linearProgress >= 1;\n      const easedProgress = completed ? 1 : this.easing(linearProgress);\n      this.value = this.from + (this.to - this.from) * easedProgress;\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to;\n        completed = true;\n      }\n    } else {\n      this.value = this.to;\n      completed = true;\n    }\n    if (completed) {\n      this.stop();\n    }\n    this.onUpdate?.(this.value, completed);\n  }\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false;\n  }\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n    this.from = this.value = from;\n    this.to = to;\n    this.lerp = lerp2;\n    this.duration = duration;\n    this.easing = easing;\n    this.currentTime = 0;\n    this.isRunning = true;\n    onStart?.();\n    this.onUpdate = onUpdate;\n  }\n};\n\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n  let timer;\n  return function(...args) {\n    let context = this;\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = void 0;\n      callback.apply(context, args);\n    }, delay);\n  };\n}\n\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n  constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}) {\n    this.wrapper = wrapper;\n    this.content = content;\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue);\n      if (this.wrapper instanceof Window) {\n        window.addEventListener("resize", this.debouncedResize, false);\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n        this.wrapperResizeObserver.observe(this.wrapper);\n      }\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n      this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  width = 0;\n  height = 0;\n  scrollHeight = 0;\n  scrollWidth = 0;\n  // These are instanciated in the constructor as they need information from the options\n  debouncedResize;\n  wrapperResizeObserver;\n  contentResizeObserver;\n  destroy() {\n    this.wrapperResizeObserver?.disconnect();\n    this.contentResizeObserver?.disconnect();\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener("resize", this.debouncedResize, false);\n    }\n  }\n  resize = () => {\n    this.onWrapperResize();\n    this.onContentResize();\n  };\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n    } else {\n      this.width = this.wrapper.clientWidth;\n      this.height = this.wrapper.clientHeight;\n    }\n  };\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight;\n      this.scrollWidth = this.content.scrollWidth;\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight;\n      this.scrollWidth = this.wrapper.scrollWidth;\n    }\n  };\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n};\n\n// packages/core/src/emitter.ts\nvar Emitter = class {\n  events = {};\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event, ...args) {\n    let callbacks = this.events[event] || [];\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args);\n    }\n  }\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb]);\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i);\n    };\n  }\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event, callback) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i);\n  }\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {};\n  }\n};\n\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = { passive: false };\nvar VirtualScroll = class {\n  constructor(element, options = { wheelMultiplier: 1, touchMultiplier: 1 }) {\n    this.element = element;\n    this.options = options;\n    window.addEventListener("resize", this.onWindowResize, false);\n    this.onWindowResize();\n    this.element.addEventListener("wheel", this.onWheel, listenerOptions);\n    this.element.addEventListener(\n      "touchstart",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.addEventListener(\n      "touchmove",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.addEventListener("touchend", this.onTouchEnd, listenerOptions);\n  }\n  touchStart = {\n    x: 0,\n    y: 0\n  };\n  lastDelta = {\n    x: 0,\n    y: 0\n  };\n  window = {\n    width: 0,\n    height: 0\n  };\n  emitter = new Emitter();\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy();\n    window.removeEventListener("resize", this.onWindowResize, false);\n    this.element.removeEventListener("wheel", this.onWheel, listenerOptions);\n    this.element.removeEventListener(\n      "touchstart",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      "touchmove",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      "touchend",\n      this.onTouchEnd,\n      listenerOptions\n    );\n  }\n  /**\n   * Event handler for \'touchstart\' event\n   *\n   * @param event Touch event\n   */\n  onTouchStart = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: 0,\n      y: 0\n    };\n    this.emitter.emit("scroll", {\n      deltaX: 0,\n      deltaY: 0,\n      event\n    });\n  };\n  /** Event handler for \'touchmove\' event */\n  onTouchMove = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY\n    };\n    this.emitter.emit("scroll", {\n      deltaX,\n      deltaY,\n      event\n    });\n  };\n  onTouchEnd = (event) => {\n    this.emitter.emit("scroll", {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event\n    });\n  };\n  /** Event handler for \'wheel\' event */\n  onWheel = (event) => {\n    let { deltaX, deltaY, deltaMode } = event;\n    const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n    const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n    deltaX *= multiplierX;\n    deltaY *= multiplierY;\n    deltaX *= this.options.wheelMultiplier;\n    deltaY *= this.options.wheelMultiplier;\n    this.emitter.emit("scroll", { deltaX, deltaY, event });\n  };\n  onWindowResize = () => {\n    this.window = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  };\n};\n\n// packages/core/src/lenis.ts\nvar Lenis = class {\n  _isScrolling = false;\n  // true when scroll is animating\n  _isStopped = false;\n  // true if user should not be able to scroll - enable/disable programmatically\n  _isLocked = false;\n  // same as isStopped but enabled/disabled when scroll reaches target\n  _preventNextNativeScrollEvent = false;\n  _resetVelocityTimeout = null;\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching;\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0;\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: \'bar\'\n   *   }\n   * })\n   */\n  userData = {};\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0;\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0;\n  /**\n   * The direction of the scroll\n   */\n  direction = 0;\n  /**\n   * The options passed to the lenis instance\n   */\n  options;\n  /**\n   * The target scroll value\n   */\n  targetScroll;\n  /**\n   * The animated scroll value\n   */\n  animatedScroll;\n  // These are instanciated here as they don\'t need information from the options\n  animate = new Animate();\n  emitter = new Emitter();\n  // These are instanciated in the constructor as they need information from the options\n  dimensions;\n  // This is not private because it\'s used in the Snap class\n  virtualScroll;\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaMultiplier = 35,\n    duration,\n    // in seconds\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp: lerp2 = 0.1,\n    infinite = false,\n    orientation = "vertical",\n    // vertical, horizontal\n    gestureOrientation = "vertical",\n    // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    __experimental__naiveDimensions = false\n  } = {}) {\n    window.lenisVersion = version;\n    if (!wrapper || wrapper === document.documentElement || wrapper === document.body) {\n      wrapper = window;\n    }\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaMultiplier,\n      duration,\n      easing,\n      lerp: lerp2,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      __experimental__naiveDimensions\n    };\n    this.dimensions = new Dimensions(wrapper, content, { autoResize });\n    this.updateClassName();\n    this.targetScroll = this.animatedScroll = this.actualScroll;\n    this.options.wrapper.addEventListener("scroll", this.onNativeScroll, false);\n    this.options.wrapper.addEventListener(\n      "pointerdown",\n      this.onPointerDown,\n      false\n    );\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier\n    });\n    this.virtualScroll.on("scroll", this.onVirtualScroll);\n  }\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy();\n    this.options.wrapper.removeEventListener(\n      "scroll",\n      this.onNativeScroll,\n      false\n    );\n    this.options.wrapper.removeEventListener(\n      "pointerdown",\n      this.onPointerDown,\n      false\n    );\n    this.virtualScroll.destroy();\n    this.dimensions.destroy();\n    this.cleanUpClassName();\n  }\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  off(event, callback) {\n    return this.emitter.off(event, callback);\n  }\n  setScroll(scroll) {\n    if (this.isHorizontal) {\n      this.rootElement.scrollLeft = scroll;\n    } else {\n      this.rootElement.scrollTop = scroll;\n    }\n  }\n  onPointerDown = (event) => {\n    if (event.button === 1) {\n      this.reset();\n    }\n  };\n  onVirtualScroll = (data) => {\n    if (typeof this.options.virtualScroll === "function" && this.options.virtualScroll(data) === false)\n      return;\n    const { deltaX, deltaY, event } = data;\n    this.emitter.emit("virtual-scroll", { deltaX, deltaY, event });\n    if (event.ctrlKey) return;\n    if (event.lenisStopPropagation) return;\n    const isTouch = event.type.includes("touch");\n    const isWheel = event.type.includes("wheel");\n    this.isTouching = event.type === "touchstart" || event.type === "touchmove";\n    const isTapToStop = this.options.syncTouch && isTouch && event.type === "touchstart" && !this.isStopped && !this.isLocked;\n    if (isTapToStop) {\n      this.reset();\n      return;\n    }\n    const isClick = deltaX === 0 && deltaY === 0;\n    const isUnknownGesture = this.options.gestureOrientation === "vertical" && deltaY === 0 || this.options.gestureOrientation === "horizontal" && deltaX === 0;\n    if (isClick || isUnknownGesture) {\n      return;\n    }\n    let composedPath = event.composedPath();\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n    const prevent = this.options.prevent;\n    if (!!composedPath.find(\n      (node) => node instanceof HTMLElement && (typeof prevent === "function" && prevent?.(node) || node.hasAttribute?.("data-lenis-prevent") || isTouch && node.hasAttribute?.("data-lenis-prevent-touch") || isWheel && node.hasAttribute?.("data-lenis-prevent-wheel"))\n    ))\n      return;\n    if (this.isStopped || this.isLocked) {\n      event.preventDefault();\n      return;\n    }\n    const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n    if (!isSmooth) {\n      this.isScrolling = "native";\n      this.animate.stop();\n      event.lenisStopPropagation = true;\n      return;\n    }\n    let delta = deltaY;\n    if (this.options.gestureOrientation === "both") {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n    } else if (this.options.gestureOrientation === "horizontal") {\n      delta = deltaX;\n    }\n    if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n      event.lenisStopPropagation = true;\n    }\n    event.preventDefault();\n    const syncTouch = isTouch && this.options.syncTouch;\n    const isTouchEnd = isTouch && event.type === "touchend";\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 5;\n    if (hasTouchInertia) {\n      delta = this.velocity * this.options.touchInertiaMultiplier;\n    }\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...syncTouch ? {\n        lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n      } : {\n        lerp: this.options.lerp,\n        duration: this.options.duration,\n        easing: this.options.easing\n      }\n    });\n  };\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize();\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.emit();\n  }\n  emit() {\n    this.emitter.emit("scroll", this);\n  }\n  onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout);\n      this._resetVelocityTimeout = null;\n    }\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false;\n      return;\n    }\n    if (this.isScrolling === false || this.isScrolling === "native") {\n      const lastScroll = this.animatedScroll;\n      this.animatedScroll = this.targetScroll = this.actualScroll;\n      this.lastVelocity = this.velocity;\n      this.velocity = this.animatedScroll - lastScroll;\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      );\n      this.isScrolling = "native";\n      this.emit();\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity;\n          this.velocity = 0;\n          this.isScrolling = false;\n          this.emit();\n        }, 400);\n      }\n    }\n  };\n  reset() {\n    this.isLocked = false;\n    this.isScrolling = false;\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.lastVelocity = this.velocity = 0;\n    this.animate.stop();\n  }\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return;\n    this.isStopped = false;\n    this.reset();\n  }\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    this.animate.stop();\n    this.reset();\n  }\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf(time) {\n    const deltaTime = time - (this.time || time);\n    this.time = time;\n    this.animate.advance(deltaTime * 1e-3);\n  }\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log(\'onStart\')\n   *   },\n   *   onComplete: () => {\n   *     console.log(\'onComplete\')\n   *   },\n   * })\n   */\n  scrollTo(target, {\n    offset = 0,\n    immediate = false,\n    lock = false,\n    duration = this.options.duration,\n    easing = this.options.easing,\n    lerp: lerp2 = this.options.lerp,\n    onStart,\n    onComplete,\n    force = false,\n    // scroll even if stopped\n    programmatic = true,\n    // called from outside of the class\n    userData\n  } = {}) {\n    if ((this.isStopped || this.isLocked) && !force) return;\n    if (typeof target === "string" && ["top", "left", "start"].includes(target)) {\n      target = 0;\n    } else if (typeof target === "string" && ["bottom", "right", "end"].includes(target)) {\n      target = this.limit;\n    } else {\n      let node;\n      if (typeof target === "string") {\n        node = document.querySelector(target);\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        node = target;\n      }\n      if (node) {\n        if (this.options.wrapper !== window) {\n          const wrapperRect = this.rootElement.getBoundingClientRect();\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n        }\n        const rect = node.getBoundingClientRect();\n        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n      }\n    }\n    if (typeof target !== "number") return;\n    target += offset;\n    target = Math.round(target);\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll;\n      }\n    } else {\n      target = clamp(0, target, this.limit);\n    }\n    if (target === this.targetScroll) {\n      onStart?.(this);\n      onComplete?.(this);\n      return;\n    }\n    this.userData = userData ?? {};\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target;\n      this.setScroll(this.scroll);\n      this.reset();\n      this.preventNextNativeScrollEvent();\n      this.emit();\n      onComplete?.(this);\n      this.userData = {};\n      return;\n    }\n    if (!programmatic) {\n      this.targetScroll = target;\n    }\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp: lerp2,\n      onStart: () => {\n        if (lock) this.isLocked = true;\n        this.isScrolling = "smooth";\n        onStart?.(this);\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = "smooth";\n        this.lastVelocity = this.velocity;\n        this.velocity = value - this.animatedScroll;\n        this.direction = Math.sign(this.velocity);\n        this.animatedScroll = value;\n        this.setScroll(this.scroll);\n        if (programmatic) {\n          this.targetScroll = value;\n        }\n        if (!completed) this.emit();\n        if (completed) {\n          this.reset();\n          this.emit();\n          onComplete?.(this);\n          this.userData = {};\n          this.preventNextNativeScrollEvent();\n        }\n      }\n    });\n  }\n  preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true;\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false;\n    });\n  }\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? "x" : "y"];\n    }\n  }\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === "horizontal";\n  }\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;\n  }\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n  }\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    return this.limit === 0 ? 1 : this.scroll / this.limit;\n  }\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling;\n  }\n  set isScrolling(value) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped;\n  }\n  set isStopped(value) {\n    if (this._isStopped !== value) {\n      this._isStopped = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    if (this._isLocked !== value) {\n      this._isLocked = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === "smooth";\n  }\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = "lenis";\n    if (this.isStopped) className += " lenis-stopped";\n    if (this.isLocked) className += " lenis-locked";\n    if (this.isScrolling) className += " lenis-scrolling";\n    if (this.isScrolling === "smooth") className += " lenis-smooth";\n    return className;\n  }\n  updateClassName() {\n    this.cleanUpClassName();\n    this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n  }\n  cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, "").trim();\n  }\n};\n\n//# sourceMappingURL=lenis.mjs.map\n\n//# sourceURL=webpack:///./node_modules/lenis/dist/lenis.mjs?')},"./src/js/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_header_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/header.js */ "./src/js/modules/header.js");\n/* harmony import */ var _modules_to_top_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/to-top.js */ "./src/js/modules/to-top.js");\n/* harmony import */ var _modules_tags_animation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/tags-animation.js */ "./src/js/modules/tags-animation.js");\n/* harmony import */ var _modules_slider_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/slider.js */ "./src/js/modules/slider.js");\n/* harmony import */ var _modules_accordion_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/accordion.js */ "./src/js/modules/accordion.js");\n/* harmony import */ var _modules_form_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/form.js */ "./src/js/modules/form.js");\n/* harmony import */ var _modules_offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/offset.js */ "./src/js/modules/offset.js");\n/* harmony import */ var _modules_lenis_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/lenis.js */ "./src/js/modules/lenis.js");\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/js/index.js?')},"./src/js/modules/accordion.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\ndocument.querySelector('.accordion').addEventListener('click', (e) => {\n\tif (e.target.classList.contains('accordion-item__trigger') || e.target.closest('.accordion-item__trigger')) {\n\t\tconst parentItem = e.target.closest('.accordion-item');\n\t\tconst parentTrigger = parentItem.querySelector('.accordion-item__trigger');\n\t\tconst triggerButton = parentTrigger.querySelector('.accordion-item__button');\n\t\tconst contentLink = parentItem.querySelector('.accordion-item__link');\n\n\t\tparentItem.classList.toggle('accordion-item_active');\n\n\t\ttriggerButton.getAttribute('aria-expanded') === 'false' ? triggerButton.setAttribute('aria-expanded', true) : triggerButton.setAttribute('aria-expanded', false);\n\n\t\t// Collapsible content element\n\t\tparentItem.querySelector('.accordion-item__content').classList.toggle('collapsible_collapsed');\n\n\t\tcontentLink.tabIndex === -1 ? (contentLink.tabIndex = 0) : contentLink.tabIndex === -1;\n\t}\n});\n\n\n//# sourceURL=webpack:///./src/js/modules/accordion.js?")},"./src/js/modules/form.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\nconst form = document.forms[0];\nlet inputs = form.querySelectorAll('input');\nconst submitBtn = form.querySelector('.form__button');\n\ninputs.forEach((el) => {\n\tel.addEventListener('blur', (e) => {\n\t\tif (e.target.required && !e.target.value) {\n\t\t\te.target.parentElement.classList.add('form__input-wrapper_hint');\n\t\t} else {\n\t\t\te.target.parentElement.classList.remove('form__input-wrapper_hint');\n\t\t}\n\t});\n\tel.addEventListener('change', (e) => {\n\t\tcheckEmptyInput(e.target);\n\t});\n\tel.addEventListener('input', (e) => {\n\t\tif (!!e.target.value) removeError(e.target);\n\t});\n});\n\nsubmitBtn.addEventListener('click', (e) => {\n\te.preventDefault();\n\n\tinputs.forEach((el) => {\n\t\tif (!el.checkValidity()) {\n\t\t\tel.parentElement.classList.add('form__input-wrapper_invalid');\n\t\t\tel.parentElement.classList.add('form__input-wrapper_hint');\n\t\t\tel.classList.add('form__input_invalid');\n\t\t}\n\t});\n\tif (form.checkValidity()) form.submit();\n});\n\nfunction checkEmptyInput(target) {\n\tif (target.value !== '') {\n\t\ttarget.nextElementSibling.classList.add('form__label_not-empty');\n\t} else {\n\t\ttarget.nextElementSibling.classList.remove('form__label_not-empty');\n\t}\n}\n\nfunction removeError(target) {\n\ttarget.parentElement.classList.remove('form__input-wrapper_invalid');\n\ttarget.classList.remove('form__input_invalid');\n}\n\n\n//# sourceURL=webpack:///./src/js/modules/form.js?")},"./src/js/modules/header.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n// Header nav\nconst header = document.querySelector('.header');\nconst menuButton = document.querySelector('.navigation__burger');\nconst menuBody = document.querySelector('.navigation__links-list');\nconst lockPaddingValue = window.innerWidth - document.querySelector('.page').offsetWidth + 'px';\nconst lockPadding = document.querySelectorAll('.lock-padding');\nlet menuIsOpen = false;\nconst media = window.matchMedia('(width < 768px)');\n\nfunction setupMenu(e) {\n\tif (e.matches) {\n\t\tmenuBody.setAttribute('aria-hidden', 'true');\n\t\tmenuButton.setAttribute('aria-hidden', 'false');\n\t} else {\n\t\tmenuBody.setAttribute('aria-hidden', 'false');\n\t\tmenuButton.setAttribute('aria-hidden', 'true');\n\t}\n}\n\nsetupMenu(media);\nmedia.addEventListener('change', (e) => {\n\tsetupMenu(e);\n});\n\ndocument.querySelector('.header').addEventListener('keydown', (e) => {\n\tif (menuIsOpen && e.code === 'Escape') closeMenu();\n});\n\nif (menuButton) {\n\tmenuButton.addEventListener('click', () => {\n\t\tdocument.documentElement.classList.contains('_lock') ? closeMenu() : openMenu();\n\t});\n}\n\nwindow.addEventListener('resize', (e) => {\n\tif (e.currentTarget.innerWidth >= 768 && menuIsOpen) closeMenu();\n});\n\nfunction openMenu() {\n\tif (header.classList.contains('hide')) header.classList.remove('hide');\n\n\tdocument.documentElement.classList.add('_lock');\n\tmenuButton.classList.add('navigation__burger_active');\n\tmenuButton.setAttribute('aria-expanded', true);\n\tmenuBody.setAttribute('aria-hidden', false);\n\tmenuBody.classList.add('navigation__links-list_active');\n\tmenuBody.classList.toggle('visible');\n\n\tif (lockPadding.length > 0) {\n\t\tlockPadding.forEach((el) => (el.style.paddingRight = lockPaddingValue));\n\t}\n\tdocument.body.style.paddingRight = lockPaddingValue;\n\n\tmenuIsOpen = true;\n}\n\nfunction closeMenu() {\n\tdocument.documentElement.classList.remove('_lock');\n\tmenuButton.setAttribute('aria-expanded', false);\n\tmenuButton.classList.remove('navigation__burger_active');\n\tmenuBody.setAttribute('aria-hidden', true);\n\tmenuBody.classList.remove('navigation__links-list_active');\n\tsetTimeout(() => menuBody.classList.toggle('visible'), 400);\n\n\tif (lockPadding.length > 0) {\n\t\tlockPadding.forEach((el) => (el.style.paddingRight = 0));\n\t}\n\tdocument.body.style.paddingRight = 0;\n\n\tmenuIsOpen = false;\n}\n\n// Header nav focus lock\nconst focusableElements = header.querySelectorAll('a[href]:not([disabled]), button:not([disabled])');\nconst firstFocusableElement = focusableElements[0];\nconst lastFocusableElement = focusableElements[focusableElements.length - 1];\n\nconst KEYCODE_TAB = 9;\n\nheader.addEventListener('keydown', (e) => {\n\tif (document.documentElement.classList.contains('_lock') && (e.key === 'Tab' || e.keyCode === KEYCODE_TAB)) {\n\t\tif (e.shiftKey) {\n\t\t\tif (document.activeElement === firstFocusableElement) {\n\t\t\t\tlastFocusableElement.focus();\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t} else {\n\t\t\tif (document.activeElement === lastFocusableElement) {\n\t\t\t\tfirstFocusableElement.focus();\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Header slide up on scroll\nlet lastScroll = 0;\nconst defaultOffset = 100;\n\nconst scrollPosition = () => window.pageYOffset || document.documentElement.scrollTop;\nconst containSlideUp = () => header.classList.contains('slide-up');\n\nwindow.addEventListener('scroll', () => {\n\tif (scrollPosition() > lastScroll && !containSlideUp() && scrollPosition() > defaultOffset) {\n\t\theader.classList.add('slide-up');\n\t\tfocusableElements.forEach((el) => {\n\t\t\tif (el === document.activeElement) el.blur();\n\t\t\tel.tabIndex = -1;\n\t\t});\n\t} else if (scrollPosition() < lastScroll && containSlideUp()) {\n\t\theader.classList.remove('slide-up');\n\t\tfocusableElements.forEach((el) => (el.tabIndex = 0));\n\t}\n\n\tlastScroll = scrollPosition();\n});\n\n// Link page scroll\ndocument.addEventListener('click', (e) => {\n\tif (e.target.classList.contains('smooth-scroll-link')) {\n\t\te.preventDefault();\n\n\t\tif (menuIsOpen) closeMenu();\n\n\t\tconst targetID = document.querySelector(`${e.target.getAttribute('href')}`);\n\t\tconst scrollCoord = window.pageYOffset > targetID.offsetTop ? targetID.offsetTop - header.clientHeight : targetID.offsetTop;\n\n\t\twindow.scrollTo({\n\t\t\tbehavior: 'smooth',\n\t\t\ttop: scrollCoord,\n\t\t});\n\t}\n});\n\n\n//# sourceURL=webpack:///./src/js/modules/header.js?")},"./src/js/modules/lenis.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lenis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lenis */ "./node_modules/lenis/dist/lenis.mjs");\n\n\nconst lenis = new lenis__WEBPACK_IMPORTED_MODULE_0__["default"]()\n\nfunction raf(time) {\n\tlenis.raf(time)\n\trequestAnimationFrame(raf)\n}\n\nrequestAnimationFrame(raf)\n\n\n//# sourceURL=webpack:///./src/js/modules/lenis.js?')},"./src/js/modules/offset.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\nlet bottom = document.querySelector('.bottom');\nlet offset = document.querySelector('.offset');\n\noffsetSize();\n\nwindow.addEventListener('resize', offsetSize);\n\nfunction offsetSize() {\n\toffset.style.paddingBottom = `${bottom.clientHeight}px`;\n}\n\n\n//# sourceURL=webpack:///./src/js/modules/offset.js?")},"./src/js/modules/slider.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n// Slider\nlet isDown = false;\nlet startX;\nlet scrollLeft;\nconst slider = document.querySelector('.slider__wrapper');\n\nconst end = () => {\n\tisDown = false;\n\tslider.classList.remove('slider__wrapper_active');\n};\n\nconst start = (e) => {\n\tisDown = true;\n\tslider.classList.add('slider__wrapper_active');\n\tstartX = e.pageX || e.touches[0].pageX - slider.offsetLeft;\n\tscrollLeft = slider.scrollLeft;\n};\n\nconst move = (e) => {\n\tif (!isDown) return;\n\n\tif (e.type === 'mousemove') e.preventDefault();\n\n\tconst x = e.pageX || e.touches[0].pageX - slider.offsetLeft;\n\tconst dist = x - startX;\n\tslider.scrollLeft = scrollLeft - dist;\n};\n\n// Slider cursor\nconst addDragCursor = (e) => {\n\tconst cursor = slider.parentElement.querySelector('.drag-cursor');\n\n\tif (cursor) {\n\t\tcursor.classList.remove('drag-cursor_hidden');\n\t} else {\n\t\tconst cursorTemplate = slider.previousElementSibling.content;\n\t\tslider.parentElement.prepend(cursorTemplate);\n\n\t\tlet newCursor = slider.parentElement.querySelector('.drag-cursor');\n\t\tnewCursor.style.left = e.clientX + 'px';\n\t\tnewCursor.style.top = e.clientY + 'px';\n\t}\n};\n\nconst moveDragCursor = (e) => {\n\tconst cursor = document.querySelector('.drag-cursor');\n\tlet x = e.clientX;\n\tlet y = e.clientY;\n\n\tif (cursor) {\n\t\tcursor.style.left = x + 'px';\n\t\tcursor.style.top = y + 'px';\n\t}\n};\n\nconst removeDragCursor = () => {\n\tconst cursor = slider.parentElement.querySelector('.drag-cursor');\n\n\tif (cursor) {\n\t\tcursor.classList.add('drag-cursor_hidden');\n\t}\n};\n\n// Listeners\nwindow.addEventListener('load', () => {\n\tslider.addEventListener('mousedown', start);\n\tslider.addEventListener('touchstart', start);\n\n\tslider.addEventListener('mousemove', move);\n\tslider.addEventListener('touchmove', move);\n\n\tslider.addEventListener('mouseleave', end);\n\tslider.addEventListener('mouseup', end);\n\tslider.addEventListener('touchend', end);\n\n\tslider.addEventListener('mouseenter', addDragCursor);\n\tslider.addEventListener('mousemove', moveDragCursor);\n\tslider.addEventListener('mouseleave', removeDragCursor);\n\n\tslider.addEventListener('mousedown', () => {\n\t\tconst cursor = slider.parentElement.querySelector('.drag-cursor');\n\t\tif (cursor) {\n\t\t\tcursor.classList.add('drag-cursor_active');\n\t\t}\n\t});\n\tslider.addEventListener('mouseup', () => {\n\t\tconst cursor = slider.parentElement.querySelector('.drag-cursor');\n\t\tif (cursor) {\n\t\t\tcursor.classList.remove('drag-cursor_active');\n\t\t}\n\t});\n});\n\n\n//# sourceURL=webpack:///./src/js/modules/slider.js?")},"./src/js/modules/tags-animation.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\nconst tags = document.querySelectorAll('.tags');\n\nif (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) addAnimation();\n\nfunction addAnimation() {\n\ttags.forEach((tagsBlock) => {\n\t\ttagsBlock.setAttribute('data-animated', true);\n\n\t\tcreateCopy(tagsBlock);\n\t});\n}\n\nfunction createCopy(target) {\n\tconst rows = target.querySelectorAll('.tags__row');\n\trows.forEach((row) => {\n\t\tconst rowContent = Array.from(row.children);\n\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\trowContent.forEach((elem) => {\n\t\t\t\tcopyPast(elem, row);\n\t\t\t});\n\t\t}\n\t});\n}\n\nfunction copyPast(elem, target) {\n\tconst duplicatedElem = elem.cloneNode(true);\n\tduplicatedElem.setAttribute('aria-hidden', true);\n\ttarget.append(duplicatedElem);\n}\n\n\n//# sourceURL=webpack:///./src/js/modules/tags-animation.js?")},"./src/js/modules/to-top.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\nconst toTop = document.querySelector('.to-top');\n\nconst checkHide = (arg) => {\n\targ.currentTarget.scrollY > document.documentElement.clientHeight ? toTop.classList.remove('hidden') : toTop.classList.add('hidden');\n};\n\ntoTop.addEventListener('click', () => {\n\twindow.scrollTo(0, 0);\n\ttoTop.classList.add('hidden');\n});\n\nwindow.addEventListener('scroll', (e) => {\n\tcheckHide(e);\n});\n\n\n//# sourceURL=webpack:///./src/js/modules/to-top.js?")}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];return void 0!==t||(t=__webpack_module_cache__[e]={exports:{}},__webpack_modules__[e](t,t.exports,__webpack_require__)),t.exports}__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/js/index.js")})();